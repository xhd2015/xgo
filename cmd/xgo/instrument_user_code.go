package main

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/xhd2015/xgo/support/fileutil"
	"github.com/xhd2015/xgo/support/git"
	"github.com/xhd2015/xgo/support/instrument"
	"github.com/xhd2015/xgo/support/instrument/overlay"
)

func getLocalXgoGenDir(projectDir string) (string, error) {
	xgoDir, err := getLocalXgoDir(projectDir)
	if err != nil {
		return "", err
	}
	xgoGenDir := filepath.Join(xgoDir, "gen")

	// to avoid `go mod vendor` detecting this gen dir
	xgoGenGoMod := filepath.Join(xgoGenDir, "go.mod")
	stat, statErr := os.Stat(xgoGenGoMod)
	if statErr != nil {
		if !os.IsNotExist(statErr) {
			return "", statErr
		}
	} else {
		if !stat.IsDir() {
			return xgoGenDir, nil
		}
		err = os.RemoveAll(xgoGenGoMod)
		if err != nil {
			return "", err
		}
	}

	err = os.MkdirAll(xgoGenDir, 0755)
	if err != nil {
		return "", err
	}

	err = os.WriteFile(xgoGenGoMod, []byte("// empty go.mod generated by xgo to avoid found by go mod tidy or go mod vendor\n"), 0644)
	if err != nil {
		return "", err
	}

	return xgoGenDir, nil
}

func getLocalXgoDir(projectDir string) (string, error) {
	xgoDir := filepath.Join(projectDir, ".xgo")
	stat, statErr := os.Stat(xgoDir)
	if statErr != nil {
		if !os.IsNotExist(statErr) {
			return "", statErr
		}
	} else {
		if !stat.IsDir() {
			return "", fmt.Errorf("%s is not a directory", humanReadablePath(xgoDir))
		}
		return xgoDir, nil
	}
	err := os.MkdirAll(xgoDir, 0755)
	if err != nil {
		return "", err
	}
	topLevel, _ := git.ShowTopLevel(projectDir)
	if topLevel != "" {
		// add .xgo/gen to .gitignore
		err := fileutil.UpdateFile(filepath.Join(topLevel, ".gitignore"), func(content []byte) (bool, []byte, error) {
			if bytes.Contains(content, []byte(".xgo/gen\n")) {
				return false, content, nil
			}
			var prefix string
			if len(content) > 0 && !bytes.HasSuffix(content, []byte("\n")) {
				prefix = "\n"
			}
			return true, append(content, []byte(prefix+".xgo/gen\n")...), nil
		})
		if err != nil {
			return "", err
		}
	}

	return xgoDir, nil
}

func InstrumentUserCode(projectDir string, overlayFS overlay.Overlay, mainModule string) error {
	return instrument.InstrumentUserCode(projectDir, overlayFS, []string{mainModule + "/src/..."})
}

func humanReadablePath(path string) string {
	wd, err := os.Getwd()
	if err != nil {
		return path
	}
	rel, err := filepath.Rel(wd, path)
	if err != nil {
		return path
	}
	if strings.Count(rel, ".."+string(filepath.Separator)) > 2 {
		return path
	}
	return rel
}
