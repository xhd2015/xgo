// This file should be inserted into reflect to provide hack points
// the 'go:build ignore' line will be removed when copy to goroot

//go:build ignore

package reflect

import (
	"internal/abi"
	"unsafe"
)

// ensure unsafe is imported
var _ unsafe.Pointer
var _ abi.Type

func init() {
	__xgo_link_set_all_method_by_name_impl(__xgo_get_all_method_by_name)

}
func __xgo_link_set_all_method_by_name_impl(fn func(v interface{}, name string) interface{}) {
	// warning
	// panic("failed to link __xgo_link_set_all_method_by_name_impl(requires xgo).")
}

func __xgo_get_all_method_by_name(v interface{}, name string) interface{} {
	m := ValueOf(v).__xgo_get_all_method_by_name(name)
	if !m.IsValid() {
		return nil
	}
	return m.Interface()
}

// --- these code will be generated by xgo ------
// --- they all slightly different across different go versions ----

// func (v Value) __xgo_all_method_by_name(name string) Value {
// 	if v.typ() == nil {
// 		panic(&ValueError{"reflect.Value.MethodByName", Invalid})
// 	}
// 	if v.flag&flagMethod != 0 {
// 		return Value{}
// 	}
// 	m, ok := toRType(v.typ()).__xgo_all_method_by_name(name)
// 	if !ok {
// 		return Value{}
// 	}
// 	return v.Method(m.Index)
// }
// func (t *rtype) __xgo_all_method_by_name(name string) (m Method, ok bool) {
// 	if t.Kind() == Interface {
// 		tt := (*interfaceType)(unsafe.Pointer(t))
// 		return tt.MethodByName(name)
// 	}
// 	ut := t.uncommon()
// 	if ut == nil {
// 		return Method{}, false
// 	}

// 	methods := ut.Methods()

// 	// We are looking for the first index i where the string becomes >= s.
// 	// This is a copy of sort.Search, with f(h) replaced by (t.nameOff(methods[h].name).name() >= name).
// 	i, j := 0, len(methods)
// 	for i < j {
// 		h := int(uint(i+j) >> 1) // avoid overflow when computing h
// 		// i â‰¤ h < j
// 		if !(t.nameOff(methods[h].Name).Name() >= name) {
// 			i = h + 1 // preserves f(i-1) == false
// 		} else {
// 			j = h // preserves f(j) == true
// 		}
// 	}
// 	// i == j, f(i-1) == false, and f(j) (= f(i)) == true  =>  answer is i.
// 	if i < len(methods) && name == t.nameOff(methods[i].Name).Name() {
// 		return t.Method(i), true
// 	}

// 	return Method{}, false
// }
